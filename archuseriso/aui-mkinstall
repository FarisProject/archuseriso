#!/usr/bin/env bash
#
# Copyright (C) 2021 Laurent Jourden <laurent85@enarel.fr>
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Script to install Arch Linux on a usb drive from an
# archuseriso iso image.

set -e -u

appname="${0##*/}"
encryption="no"
ext4journal="yes"
f2fs="no"
espsize=""
isoname=""
MINCAPACITY=16000000000 # 16 GB
rootsize=""
usbdevice=""
username="archie"
WD="${PWD}"
workdir="$(mktemp -u auiwork.XXXXXXXX)"

_usage () {
        echo
        echo 'aui-mkinstall, performs a normal installation on a USB drive.'
        echo
        echo 'Command synopsis:'
        echo 'aui-mkinstall [options] <iso image> <usb device>'
        echo
        echo 'Get help:'
        echo 'aui-mkinstall --help'
        exit "${1}"
}

_help () {
        echo
        echo 'Archuseriso tool for normal installation on a USB drive'
        echo
        echo 'Command synopsis:'
        echo 'aui-mkinstall [options] <iso image> <usb device>'
        echo
        echo 'Options:'
        echo '-h, --help                  command line help'
        echo '--encrypt                   encrypt persistent partition'
        echo '--no-journal                disable ext4 journal'
        echo '--f2fs                      use the F2FS file system for the root partition (Default Ext4)'
        echo '--size-part2 integer[g|G]   1st partition size in GiB (Boot & efi partition, FAT)'
        echo '--size-part3 integer[g|G]   2nd partition size in GiB (Root partition, Ext4/F2FS)'
        echo "--username <user>           set a custom username, default username is 'archie'"
        echo
        echo 'Example:'
        echo 'aui-mkinstall --encrypt archuseriso-xfce-1231-x64.iso /dev/sdc'
        echo
        exit "${1}"
}

_msg_info () {
        local _msg="${1}"
        printf '[%s] INFO: %s\n' "${appname}" "${_msg}"
}

_cleanup() {
        local _workdirs
        _workdirs=('usb/boot' 'usb' 'squashfs' 'iso')
        for _workdir in ${_workdirs[*]}; do
                if mountpoint -q -- "${WD}/${workdir}/${_workdir}"; then
                        umount -- "${WD}/${workdir}/${_workdir}"
                fi
        done
        for _workdir in ${_workdirs[*]}; do
                if [[ -d "${WD}/${workdir}/${_workdir}" ]]; then
                        rmdir -- "${WD}/${workdir}/${_workdir}"
                fi
        done
        if [[ -d "${WD}/${workdir}" ]]; then
                rmdir -- "${WD}/${workdir}"
        fi
        if [[ -e /dev/mapper/auicrypt ]]; then
                cryptsetup close auicrypt
        fi
}

_encrypt_mkluks () {
        echo
        _msg_info "Setting up encrypted partition, type in a passphrase of your choice"
        if ! cryptsetup --label "${cryptlabel:=AUICRYPT}" --uuid "${cryptuuid:=$(uuidgen)}" -q luksFormat -- "${usbdevice}2"; then
                echo 'Encryption setup failed, exiting!'
                exit 1
        fi
        echo
        _msg_info "LUKS encryption setup done! type in your passphrase to unlock device"
        if ! cryptsetup -- open "${usbdevice}2" auicrypt; then
                echo 'Error: Could not unlock device! Exiting.'
                exit 1
        fi
        echo
        rootdevice=/dev/mapper/auicrypt
        _msg_info "Done!"
}

_encrypt_setup () {
        _msg_info "Finalizing encryption settings"
        sed -i -- "s|block|& encrypt|" "${WD}/${workdir}/usb/etc/mkinitcpio.conf"
        sed -i -- "s|root=LABEL=|cryptdevice=UUID=${cryptuuid}:auicrypt &|" \
                  "${WD}/${workdir}/usb/boot/refind_linux.conf"
        sed -i -- "s|root=LABEL=|cryptdevice=UUID=${cryptuuid}:auicrypt &|" \
                  "${WD}/${workdir}/usb/boot/syslinux/syslinux.cfg"
        _msg_info "Done!"
        _msg_info "initramfs update"
        arch-chroot -- "${WD}/${workdir}/usb" mkinitcpio -P &> /dev/null
        _msg_info "Done!"
}

_checks () {
        if [[ $# -ne 2 ]]; then
                echo 'Error: Invalid arguments!'
                _usage 1
        fi
        if [[ ${EUID} -ne 0 ]]; then
                echo 'This script must be run as root!'
                exit 1
        fi
        isoname="${1}"
        usbdevice="${2}"
        # command arguments reverse order compatibility
        if [[ $(file -- "${usbdevice}" 2> /dev/null) =~ 'MBR boot sector' ]]; then
                isoname="${2}"
                usbdevice="${1}"
        fi
        if [[ $(stat -c %t -- "${usbdevice}" 2> /dev/null) -ne 8 ]]; then
                echo "Error: ${usbdevice} is not a block device!"
                _usage 1
        fi
        if [[ $(lsblk -dnro hotplug -- "${usbdevice}" 2> /dev/null) -ne 1 ]]; then
                echo "Error: ${usbdevice} is not a removable block device!"
                _usage 1
        fi
        if [[ "$(lsblk -dnro tran -- "${usbdevice}" 2> /dev/null)" != 'usb' ]]; then
                echo "Error: ${usbdevice} is not a usb device!"
                _usage 1
        fi
        if findmnt -nr -- "${usbdevice}" > /dev/null; then
                echo "Error: ${usbdevice} appears in active mounts, unmount device before proceeding!"
                exit 1
        fi
        if [[ ! -f "${isoname}" ]]; then
                echo "file ${isoname} not found!"
                _usage 1
        fi
        if [[ ! $(file -- "${isoname}" 2> /dev/null) =~ 'MBR boot sector' ]]; then
                echo "Error: ${isoname} is not an iso image!"
                _usage 1
        fi
        # Set efi boot partition size in MiB
        if [[ -n "${espsize}" ]]; then
                if ! [[ "${espsize}" =~ ^[1-9][0-9]?+$ ]]; then
                        echo "FAT partition size error: Invalid --fat-size argument (GiB): ${espsize}"
                        _usage 1
                fi
                espsize=$(( espsize * 1024 ))
        else
                espsize=512
        fi
        # Set root partition size in MiB, free space left by default
        if [[ -n "${rootsize}" ]]; then
                if ! [[ "${rootsize}" =~ ^[1-9][0-9]?+$ ]]; then
                        echo "Ext4/F2FS partition size error: Invalid size argument (GiB): ${rootsize}"
                        _usage 1
                fi
                rootsize=$(( rootsize * 1024 ))
        fi
        if [[ "${f2fs}" == "yes" ]]; then
                if ! pacman -Q f2fs-tools &> /dev/null; then
                        echo 'f2fs-tools package not installed, aborting!'
                        exit 0
                fi
        fi
}

_init () {
        local _espsize _rootsize
        drivesize=$(blockdev --getsize64 "${usbdevice}")
        LOGICSEC=$(blockdev --getss "${usbdevice}")
        # Drive partition #1, first sector at 1 MiB
        STARTSEC=$(( 1024 * 1024 / LOGICSEC ))
        # Check usb drive capacity
        if [[ ${drivesize} -lt ${MINCAPACITY} ]]; then
                echo 'Storage capacity error!'
                exit 1
        fi
        # check partitions size don't exceed drive's capacity
        _espsize=$(( espsize * 1024 * 1024 ))
        if [[ -n "${rootsize}" ]]; then
                _rootsize=$(( rootsize * 1024 * 1024 ))
        else
                _rootsize=0
        fi
        if [[ ! ${drivesize} -gt $(( _espsize + _rootsize )) ]]; then
                echo "Size settings error: exceeds drive storage capacity!"
                exit 1
        fi
        # check usb drive capacity
        if [[ ! ${drivesize} -gt $(( _espsize + _rootsize )) ]]; then
                echo "Size settings error: exceeds drive storage capacity!"
                exit 1
        fi
}

_confirm_write () {
        # Confim write
        echo
        _msg_info "This process may take a long time depending on the drive's write speed, be patient!"
        _msg_info ""
        _msg_info "ISO file:   ${isoname}"
        _msg_info "USB device: ${usbdevice}"
        _msg_info "Configured username: ${username}"
        echo
        read -r -n1 -p "Confirm write to $(lsblk -dnro model,size -- "${usbdevice}") (N/y)? "
        echo
        if [[ ! "${REPLY}" =~ ^[Yy]$ ]]; then
                echo 'Operation canceled by user!'
                exit 0
        fi

        # Check & prepare working directory
        for mountpoint in "${workdir}" "${workdir}/"{iso,squashfs,usb}; do
                if findmnt -nr -- "${mountpoint}" > /dev/null; then
                        echo "Error: ${mountpoint} appears in active mounts, unmount before proceeding!"
                        exit 1
                fi
        done
        for mountpoint in "${workdir}" "${workdir}/"{iso,squashfs,usb}; do
                if [[ -e "${WD}/${mountpoint}" ]]; then
                       echo "Error: ${mountpoint} exists in working directory! Delete or rename before proceeding!"
                       exit 1
                fi
        done
        if [[ -e /dev/mapper/auicrypt ]]; then
                echo 'Error: cryptsetup mapping /dev/mapper/auicrypt exists! cannot proceed.'
                exit 1
        fi
        mkdir -p -- "${WD}/${workdir}/"{iso,squashfs,usb}

        # Mount iso & live filesystem
        echo
        _msg_info "Mounting iso: mountpoint ${WD}/${workdir}/iso"
        mount -o ro -- "${isoname}" "${WD}/${workdir}/iso"
        _msg_info "Done!"
        _msg_info "Mounting live image: mountpoint ${WD}/${workdir}/squashfs"
        mount -o ro -- "${WD}/${workdir}/iso/arch/x86_64/airootfs.sfs" "${WD}/${workdir}/squashfs"
        _msg_info "Done!"

        # check iso
        if [[ -f "${WD}/${workdir}/iso/aui/AUIDATA" && -d "${WD}/${workdir}/iso/aui/install" ]]; then
                eval $(grep -- aui_suffix "${WD}/${workdir}/iso/aui/AUIDATA")
                eval $(grep -- label_root "${WD}/${workdir}/iso/aui/AUIDATA")
                eval $(grep -- label_boot "${WD}/${workdir}/iso/aui/AUIDATA")
        else
                echo "Error: ${isoname} is not a compatible image!"
                umount -- "${WD}/${workdir}/squashfs"
                sleep 1
                umount -- "${WD}/${workdir}/iso"
                rmdir -- "${WD}/${workdir}/"{usb,squashfs,iso,}
                _usage 1
        fi
}

_partitions () {
        local _part_type_linux _part_type_msft
        local _start_1st_part _start_2nd_part
        local _sectors_1st_part _sectors_2nd_part
        local _size_1st_part _size_2nd_part

        # GPT Partition type : Linux Filesystem
        _part_type_linux="0FC63DAF-8483-4772-8E79-3D69D8477DE4"
        # GPT Partition type : Microsoft basic data
        _part_type_msft="EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"

        # Start sector, partition size in both sectors and MiB
        _start_1st_part=$(( STARTSEC ))
        _size_1st_part=$(( espsize * 1024 * 1024 ))
        _sectors_1st_part=$(( _size_1st_part / LOGICSEC ))
        _start_2nd_part=$(( _start_1st_part + _sectors_1st_part ))
        if [[ -n "${rootsize}" ]]; then
                _sectors_2nd_part=$(( ${rootsize/[gG]} * 1024 * 1024 * 1024 / LOGICSEC ))
        fi
	if [[ -n "${rootsize}" ]]; then
                _size_2nd_part=$(( rootsize * 1024 * 1024 ))
                _sectors_2nd_part=$(( _size_2nd_part / LOGICSEC ))
        else
                _size_2nd_part=$(( drivesize - _size_1st_part - (STARTSEC * LOGICSEC) ))
        fi

        # Wipe drive
        echo
        flock -- "${usbdevice}" wipefs --all --force -- "${usbdevice}"* > /dev/null
        sleep 1

        # New gpt partition table 
        _msg_info "Partitioning drive"
        _msg_info "new gpt label"
        echo 'label: gpt' | flock -- "${usbdevice}" sfdisk -w always -- "${usbdevice}" > /dev/null
        sleep 2

        # partition #1 boot & efi partition
        _msg_info "partition #1: boot & efi partition: $(( _size_1st_part / 1024 / 1024 )) MiB"
        echo "$(( _start_1st_part )),$(( _sectors_1st_part )),${_part_type_msft}," | flock -- "${usbdevice}" sfdisk -W always -- "${usbdevice}" > /dev/null
        sleep 2
        _msg_info "partition #2: root partition: $(( _size_2nd_part / 1024 / 1024 )) MiB"
        echo "$(( _start_2nd_part )),${_sectors_2nd_part:-},${_part_type_linux}," | flock -- "${usbdevice}" sfdisk --append -W always -- "${usbdevice}" > /dev/null
        sleep 2
        partprobe -- "${usbdevice}"
        _msg_info "Done!"
}

_format_f2fs() {
        _msg_info "partition #2: type F2FS, label ${label_root:-AUIROOT}"
        if ! flock -- "${rootdevice}" mkfs.f2fs -l "${label_root:=AUIROOT}" -O encrypt,extra_attr,compression -- "${rootdevice}" > /dev/null; then
                echo 'Formatting partition failed!'
                exit 1
        fi
}

_format_ext4 () {
        _msg_info "partition #2: type Ext4, label ${label_root:-AUIROOT}"
        if ! flock -- "${rootdevice}" mkfs.ext4 -L "${label_root:=AUIROOT}" -O encrypt -q -- "${rootdevice}"; then
                echo 'Formatting partition failed!'
                exit 1
        fi
        # disable ext4 journal
        if [[ "${ext4journal}" == "no" ]]; then
                _msg_info "Ext4 partition: journal disabled"
                tune2fs -O '^has_journal' -- "${rootdevice}" &> /dev/null
        fi
}

_format () {
        echo
        _msg_info "Formatting partitions"
        _msg_info "partition #1: type FAT, label ${label_boot:-AUIBOOT}"
        if ! flock -- "${usbdevice}1" mkfs.fat -F32 -n "${label_boot:=AUIBOOT}" -- "${usbdevice}1" > /dev/null; then
                echo 'Partition format failed!'
                exit 1
        fi
        rootdevice="${usbdevice}2"
        if [[ "${encryption}" == "yes" ]]; then
                _encrypt_mkluks
        fi
        # Root partition, filesystem type
        # Default ext4
        if [[ "${f2fs}" == "yes" ]]; then
                _format_f2fs
        else
                _format_ext4
        fi
        _msg_info "Done!"
}

_mount () {
        # Mount usb device
        echo
        _msg_info "Mounting partitions"
        _msg_info "device: ${rootdevice}, mountpoint: ${WD}/${workdir}/usb"
        mount -- "${rootdevice}" "${WD}/${workdir}/usb"
        mkdir -- "${WD}/${workdir}/usb/boot"
        _msg_info "device: ${usbdevice}1, mountpoint: ${WD}/${workdir}/usb/boot"
        mount -- "${usbdevice}1" "${WD}/${workdir}/usb/boot"
        mkdir -p -- "${WD}/${workdir}/usb/boot/EFI/BOOT"
        _msg_info "Done!"
}

_install () {
        # Copy livesystem to usb device
        echo
        _msg_info "Copying data to ${WD}/${workdir}/usb, may take some time"
        cp -aT -- "${WD}/${workdir}/squashfs" "${WD}/${workdir}/usb"
        # Copy aui install tree
        cp -aT -- "${WD}/${workdir}/iso/aui/install" "${WD}/${workdir}/usb"
        _msg_info "Done!"

        # System settings
        # * remove live settings except volatile journal
        # * fstab
        # * live user renamed 'archie', no password set

        _msg_info "Removing live settings"

        # kernel
        cp -- "${WD}/${workdir}/iso/arch/boot/x86_64/vmlinuz-linux" "${WD}/${workdir}/usb/boot/"
        cp -- "${WD}/${workdir}/iso/arch/boot/intel-ucode.img" "${WD}/${workdir}/usb/boot/"
        cp -- "${WD}/${workdir}/iso/arch/boot/amd-ucode.img" "${WD}/${workdir}/usb/boot/"
        # fstab
        sed -i -- "s|%AUIROOT%|${label_root}|;
                   s|%AUIBOOT%|${label_boot}|" \
                  "${WD}/${workdir}/usb/etc/fstab"

        # sshd, mirrorlist, logind.conf
        sed -i -- 's/^\(PermitRootLogin \).\+/#\1prohibit-password/' "${WD}/${workdir}/usb/etc/ssh/sshd_config"
        rm -r -- "${WD}/${workdir}/usb/etc/systemd/logind.conf.d"

        # live services
        arch-chroot -- "${WD}/${workdir}/usb" systemctl disable pacman-init.service choose-mirror.service --quiet
        rm -r -- "${WD}/${workdir}/usb/etc/systemd/system/"{choose-mirror.service,pacman-init.service,etc-pacman.d-gnupg.mount,getty@tty1.service.d}
        rm -- "${WD}/${workdir}/usb/root/"{.automated_script.sh,.zlogin}
        rm -- "${WD}/${workdir}/usb/etc/initcpio/hooks/archiso"

        # autologin
        if [[ -e "${WD}/${workdir}/usb/etc/lightdm/lightdm.conf" ]]; then
                sed -i -- 's/^\(autologin-user=\)live$/#\1/' "${WD}/${workdir}/usb/etc/lightdm/lightdm.conf"
                sed -i -- 's/^\(autologin-session=\).*/#\1/' "${WD}/${workdir}/usb/etc/lightdm/lightdm.conf"
        fi
        if [[ -e "${WD}/${workdir}/usb/etc/sddm.conf.d/autologin.conf" ]]; then
                rm -- "${WD}/${workdir}/usb/etc/sddm.conf.d/autologin.conf"
        fi

        # sudo
        sed -i -- 's/^\(%wheel\s.*NOPASSWD\)/# \1/' "${WD}/${workdir}/usb/etc/sudoers"
        sed -i -- 's/^#\s\(%wheel\s.*)\sALL\)$/\1/' "${WD}/${workdir}/usb/etc/sudoers"

        _msg_info "Done!"

        # Arch keyring
        _msg_info "Initialising pacman keys"
        arch-chroot -- "${WD}/${workdir}/usb" pacman-key --init &> /dev/null
        arch-chroot -- "${WD}/${workdir}/usb" pacman-key --populate archlinux &> /dev/null
        _msg_info "Done!"

        # username
        if [[ -d "${WD}/${workdir}/usb/home/live" ]]; then
                _msg_info "Configuring user ${username}"
                mv -- "${WD}/${workdir}/usb/home/live" "${WD}/${workdir}/usb/home/${username}"
                sed -i -- "s/live/${username}/g" \
                          "${WD}/${workdir}/usb/etc/"{passwd,group,shadow,gshadow} \
                          "${WD}/${workdir}/usb/etc/samba/smb.conf"
                _msg_info "Done!"
        else
                _msg_info "no user account found on the live image!"
                username="root"
                _msg_info "Done!"
        fi

        # haveged, initramfs
        arch-chroot -- "${WD}/${workdir}/usb" systemctl enable haveged --quiet
        _msg_info "initramfs update"
        arch-chroot -- "${WD}/${workdir}/usb" mkinitcpio -P &> /dev/null
        _msg_info "Done!"

        # rEFInd boot manager
        _msg_info "Setting up boot loader"
        cp -rT -- "${WD}/${workdir}/iso/EFI/BOOT/" "${WD}/${workdir}/usb/boot/EFI/BOOT/"
        cp -- "${WD}/${workdir}/iso/shellx64.efi" "${WD}/${workdir}/usb/boot/EFI/"
        cp -- "${WD}/${workdir}/iso/EFI/BOOT/icons/os_arch.png" "${WD}/${workdir}/usb/boot/vmlinuz-linux.png"
        cp -- "${WD}/${workdir}/iso/aui/refind_linux.conf" "${WD}/${workdir}/usb/boot/"
        sed -i -- "s|%AUIROOT%|${label_root}|" "${WD}/${workdir}/usb/boot/refind_linux.conf"

        # syslinux bootloader
        mkdir -p -- "${WD}/${workdir}/usb/boot/syslinux/"
        cp -- "${WD}/${workdir}/iso/aui/syslinux.cfg" "${WD}/${workdir}/usb/boot/syslinux/"
        cp -- "${WD}/${workdir}"/usb/usr/lib/syslinux/bios/*.c32 "${WD}/${workdir}/usb/boot/syslinux/"

        _msg_info "Done!"

        if [[ "${encryption}" == "yes" ]]; then
                _encrypt_setup
        fi
}

_finalize () {
        # Unmount & remove temp dirs
        echo
        _msg_info 'Unmounting work directories, may take some time, be patient!'
        umount -- "${usbdevice}1" "${rootdevice}"
        umount -- "${WD}/${workdir}/squashfs"
        sleep 1
        umount -- "${WD}/${workdir}/iso"
        rmdir -- "${WD}/${workdir}/"{usb,squashfs,iso,}

        if [[ "${encryption}" == "yes" ]]; then
                cryptsetup close auicrypt
        fi
        _msg_info "Done!"
}

_bootloader () {
        echo
        _msg_info "Installing boot loader"
        if ! syslinux --directory syslinux --install -- "${usbdevice}1" > /dev/null; then
                echo 'Bootloader installation failed!'
                exit 1
        fi
        if ! dd bs=440 count=1 conv=notrunc if=/usr/lib/syslinux/bios/gptmbr.bin of="${usbdevice}" 2> /dev/null; then
                echo 'Bootloader installation failed!'
                exit 1
        fi
        if ! sfdisk --part-attrs "${usbdevice}" 1 LegacyBIOSBootable &> /dev/null; then
                echo 'Bootloader installation failed!'
                exit 1
        fi
        _msg_info "Done!"
}

# arguments
OPTS=$(getopt -o 'h' --long 'encrypt,no-journal,f2fs,help,username:' \
                     --long 'nojournal' \
                     --long 'size-part1:,sizepart1:,size-part2:,sizepart2:' \
                     -n 'aui-mkinstall' -- "$@")
[[ $? -eq 0 ]] || _usage 1
eval set -- "${OPTS}"
unset OPTS
[[ $# -eq 1 ]] && _usage 1

while true; do
        case "$1" in
                '-h'|'--help')
                        _help 0 ;;
                '--encrypt')
                        encryption="yes"
                        shift ;;
                '--no-journal'|'--nojournal')
                        ext4journal="no"
                        shift ;;
                '--f2fs')
                        f2fs="yes"
                        shift ;;
                '--size-part1'|'--sizepart1')
                        espsize="${2/[gG]}"
                        shift 2 ;;
                '--size-part2'|'--sizepart2')
                        rootsize="${2/[gG]}"
                        shift 2 ;;
                '--username')
                        username="${2}"
                        shift 2 ;;
                '--')
                        shift
                        break ;;
        esac
done

trap _cleanup EXIT
_checks "$@"
_init
_confirm_write
_partitions
_format
_mount
_install
_finalize
_bootloader

_msg_info "Success!"
echo
echo "IMPORTANTS NOTES:"
echo "Configured username is ${username}, no password was set!"
echo
echo "Enjoy ;)"

# vim: set expandtab:
